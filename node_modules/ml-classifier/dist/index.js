import { tidy, zeros, nextFrame, image, scalar, layers, sequential, train, tensor3d, Model, loadModel, model, oneHot, tensor1d, keep } from '@tensorflow/tfjs';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var _this = undefined;
var crop = function (img) {
    var size = Math.min(img.shape[0], img.shape[1]);
    var centerHeight = img.shape[0] / 2;
    var beginHeight = centerHeight - (size / 2);
    var centerWidth = img.shape[1] / 2;
    var beginWidth = centerWidth - (size / 2);
    return img.slice([beginHeight, beginWidth, 0], [size, size, 3]);
};
// convert pixel data into a tensor
var cropAndResizeImage = function (img, dims) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, tidy(function () {
                var croppedImage = crop(image.resizeBilinear(img, dims));
                return croppedImage.expandDims(0).toFloat().div(scalar(127)).sub(scalar(1));
            })];
    });
}); };

var getClasses = function (classes) { return classes.reduce(function (labels, label) {
    var _a;
    if (labels[label] !== undefined) {
        return labels;
    }
    return __assign({}, labels, (_a = {}, _a[label] = Object.keys(labels).length, _a));
}, {}); };

var _this$1 = undefined;
var defaultLayers = function (_a) {
    var classes = _a.classes;
    return [
        layers.flatten({ inputShape: [7, 7, 256] }),
        layers.dense({
            units: 100,
            activation: 'relu',
            kernelInitializer: 'varianceScaling',
            useBias: true
        }),
        layers.dense({
            units: classes,
            kernelInitializer: 'varianceScaling',
            useBias: false,
            activation: 'softmax'
        })
    ];
};
var getBatchSize = function (batchSize, xs) {
    if (batchSize) {
        return batchSize;
    }
    if (xs !== undefined) {
        return Math.floor(xs.shape[0] * 0.4) || 1;
    }
    return undefined;
};
var getModel = function (pretrainedModel, data, classes, params, args) {
    if (args.trainingModel) {
        if (typeof args.trainingModel === 'function') {
            return args.trainingModel(data, classes, params);
        }
        return args.trainingModel;
    }
    var model$$1 = sequential({
        layers: defaultLayers({ classes: classes }),
    });
    var optimizer = train.adam(0.0001);
    model$$1.compile({
        optimizer: optimizer,
        loss: 'categoricalCrossentropy',
        metrics: ['accuracy'],
    });
    return model$$1;
};
var train$1 = function (pretrainedModel, data, classes, params, args) { return __awaiter(_this$1, void 0, void 0, function () {
    var xs, ys, model$$1, batchSize, history;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                xs = data.xs, ys = data.ys;
                if (xs === undefined || ys === undefined) {
                    throw new Error('Add some examples before training!');
                }
                model$$1 = getModel(pretrainedModel, data, classes, params, args);
                batchSize = getBatchSize(params.batchSize, xs);
                return [4 /*yield*/, model$$1.fit(xs, ys, __assign({}, params, { batchSize: batchSize, epochs: params.epochs || 20 }))];
            case 1:
                history = _a.sent();
                return [2 /*return*/, {
                        model: model$$1,
                        history: history,
                    }];
        }
    });
}); };

var _this$2 = undefined;
// import log from './log';
// import {
//   TypedArray,
// } from './types';
var loadImage = function (src) { return __awaiter(_this$2, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, new Promise(function (resolve, reject) {
                var image$$1 = new Image();
                image$$1.src = src;
                image$$1.crossOrigin = 'Anonymous';
                image$$1.onload = function () { return resolve(image$$1); };
                image$$1.onerror = function (err) { return reject(err); };
            })];
    });
}); };
var imageToUint8ClampedArray = function (image$$1, dims) { return __awaiter(_this$2, void 0, void 0, function () {
    var canvas, context, data;
    return __generator(this, function (_a) {
        canvas = document.createElement('canvas');
        context = canvas.getContext('2d');
        if (context) {
            context.drawImage.apply(context, [image$$1, 0, 0, image$$1.width, image$$1.height, 0, 0].concat(dims));
            data = context.getImageData.apply(context, [0, 0].concat(dims));
            // const data = context.getImageData(0, 0, image.width, image.height);
            return [2 /*return*/, data];
        }
        throw new Error('No context found; are you in the browser?');
    });
}); };
var loadTensorFromHTMLImage = function (image$$1, dims) { return __awaiter(_this$2, void 0, void 0, function () {
    var arr;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, imageToUint8ClampedArray(image$$1, dims)];
            case 1:
                arr = _a.sent();
                return [2 /*return*/, imageDataToTensor(arr)];
        }
    });
}); };
var imageDataToTensor = function (_a) {
    var data = _a.data, width = _a.width, height = _a.height;
    return __awaiter(_this$2, void 0, void 0, function () {
        return __generator(this, function (_b) {
            return [2 /*return*/, tensor3d(Array.from(data), [width, height, 4])];
        });
    });
};
var getTranslatedImageAsTensor = function (image$$1, dims, num) { return __awaiter(_this$2, void 0, void 0, function () {
    var loadedImage, tensor;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, nextFrame()];
            case 1:
                _a.sent();
                if (!(image$$1 instanceof tensor3d)) return [3 /*break*/, 2];
                return [2 /*return*/, image$$1];
            case 2:
                if (!(typeof image$$1 === 'string')) return [3 /*break*/, 6];
                return [4 /*yield*/, loadImage(image$$1)];
            case 3:
                loadedImage = _a.sent();
                return [4 /*yield*/, nextFrame()];
            case 4:
                _a.sent();
                return [4 /*yield*/, loadTensorFromHTMLImage(loadedImage, dims)];
            case 5: return [2 /*return*/, _a.sent()];
            case 6:
                if (!(image$$1 instanceof HTMLImageElement)) return [3 /*break*/, 9];
                return [4 /*yield*/, loadTensorFromHTMLImage(image$$1, dims)];
            case 7:
                tensor = _a.sent();
                return [4 /*yield*/, nextFrame()];
            case 8:
                _a.sent();
                return [2 /*return*/, tensor];
            case 9:
                if (!(image$$1 instanceof ImageData)) return [3 /*break*/, 11];
                return [4 /*yield*/, imageDataToTensor(image$$1)];
            case 10: return [2 /*return*/, _a.sent()];
            case 11: throw new Error('Unsupported image type');
        }
    });
}); };
var translateImages = function (origImages, dims, origLabels) { return __awaiter(_this$2, void 0, void 0, function () {
    var images, errors, labels, i, origImage, image$$1, error_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                images = [];
                errors = [];
                labels = [];
                i = 0;
                _a.label = 1;
            case 1:
                if (!(i < origImages.length)) return [3 /*break*/, 8];
                origImage = origImages[i];
                _a.label = 2;
            case 2:
                _a.trys.push([2, 4, , 5]);
                return [4 /*yield*/, getTranslatedImageAsTensor(origImage, dims, i)];
            case 3:
                image$$1 = _a.sent();
                // else, it is already a tensor
                images.push(image$$1);
                if (origLabels) {
                    labels.push(origLabels[i]);
                }
                return [3 /*break*/, 5];
            case 4:
                error_1 = _a.sent();
                errors.push({
                    image: origImage,
                    error: error_1,
                    index: i,
                });
                return [3 /*break*/, 5];
            case 5: return [4 /*yield*/, nextFrame()];
            case 6:
                _a.sent();
                _a.label = 7;
            case 7:
                i++;
                return [3 /*break*/, 1];
            case 8: return [2 /*return*/, {
                    images: images,
                    errors: errors,
                    labels: labels,
                }];
        }
    });
}); };

var _a;
var _this$3 = undefined;
var PRETRAINED_MODELS_KEYS = {
    MOBILENET: 'mobilenet_v1_0.25_224',
};
var PRETRAINED_MODELS = (_a = {},
    _a[PRETRAINED_MODELS_KEYS.MOBILENET] = {
        url: 'https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_0.25_224/model.json',
        layer: 'conv_pw_13_relu',
    },
    _a);
var loadPretrainedModel = function (pretrainedModel) {
    if (pretrainedModel === void 0) { pretrainedModel = PRETRAINED_MODELS_KEYS.MOBILENET; }
    return __awaiter(_this$3, void 0, void 0, function () {
        var config, model$$1, layer;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (pretrainedModel instanceof Model) {
                        return [2 /*return*/, pretrainedModel];
                    }
                    if (!PRETRAINED_MODELS[pretrainedModel]) {
                        throw new Error('You have supplied an invalid key for a pretrained model');
                    }
                    config = PRETRAINED_MODELS[pretrainedModel];
                    return [4 /*yield*/, loadModel(config.url)];
                case 1:
                    model$$1 = _a.sent();
                    layer = model$$1.getLayer(config.layer);
                    return [2 /*return*/, model({
                            inputs: [model$$1.inputs[0]],
                            outputs: layer.output,
                        })];
            }
        });
    });
};

var oneHot$1 = function (labelIndex, classLength) { return tidy(function () { return oneHot(tensor1d([labelIndex]).toInt(), classLength); }); };
// const turnTensorArrayIntoTensor = (tensors: tf.Tensor[]) => tensors.reduce((data?: tf.Tensor, tensor: tf.Tensor) => tf.tidy(() => {
//   if (data === undefined) {
//     return tf.keep(tensor);
//   }
//   const newData = tf.keep(data.concat(tensor, 0));
//   data.dispose();
//   return newData;
// }), undefined);
var addData = function (tensors) {
    var data = keep(tensors[0]);
    return tensors.slice(1).reduce(function (data, tensor) { return tidy(function () {
        var newData = keep(data.concat(tensor, 0));
        data.dispose();
        return newData;
    }); }, data);
};
var addLabels = function (labels, classes) {
    var classLength = Object.keys(classes).length;
    if (classLength <= 1) {
        throw new Error('You must provide more than 1 class for training');
    }
    return labels.reduce(function (data, label) {
        var labelIndex = classes[label];
        var y = oneHot$1(labelIndex, classLength);
        return tidy(function () {
            if (data === undefined) {
                return keep(y);
            }
            var old = data;
            var ys = keep(old.concat(y, 0));
            old.dispose();
            y.dispose();
            return ys;
        });
    }, undefined);
};

var getOrderedClasses = function (classes) { return Object.entries(classes).sort(function (a, b) {
    return a[1] - b[1];
}).map(function (_a) {
    var key = _a[0];
    return key;
}); };
var getName = function (classes) { return getOrderedClasses(classes).join('-'); };
var getDefaultDownloadHandler = function (classes) {
    return "downloads://ml-classifier-" + getName(classes);
};

// export { DataType } from './types';
var MLClassifier = /** @class */ (function () {
    function MLClassifier(args) {
        var _this = this;
        this.callbacks = [];
        this.data = {
            classes: {},
        };
        this.callbackFn = function (fn, type) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var _a;
            var key = "" + fn + type.substring(0, 1).toUpperCase() + type.substring(1);
            if (_this.args[key] && typeof _this.args[key] === 'function') {
                (_a = _this.args)[key].apply(_a, args);
            }
        };
        this.init = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, dims;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.callbackFn('onLoad', 'start');
                        _a = this;
                        return [4 /*yield*/, loadPretrainedModel(this.args.pretrainedModel)];
                    case 1:
                        _a.pretrainedModel = _b.sent();
                        this.callbacks.map(function (callback) { return callback(); });
                        this.callbackFn('onLoad', 'complete');
                        return [4 /*yield*/, this.getInputDims()];
                    case 2:
                        dims = _b.sent();
                        tidy(function () {
                            _this.pretrainedModel.predict(zeros([1].concat(dims, [3])));
                        });
                        return [2 /*return*/];
                }
            });
        }); };
        this.loaded = function () { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) {
                        if (_this.pretrainedModel) {
                            return resolve();
                        }
                        _this.callbacks.push(function () {
                            resolve();
                        });
                    })];
            });
        }); };
        // private cropAndActivateImage = async (image: tf.Tensor3D) => {
        this.cropAndActivateImage = function (image$$1) { return __awaiter(_this, void 0, void 0, function () {
            var dims, processedImage, pred;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.loaded()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.getInputDims()];
                    case 2:
                        dims = _a.sent();
                        return [4 /*yield*/, nextFrame()];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, cropAndResizeImage(image$$1, dims)];
                    case 4:
                        processedImage = _a.sent();
                        return [4 /*yield*/, nextFrame()];
                    case 5:
                        _a.sent();
                        pred = this.pretrainedModel.predict(processedImage);
                        return [2 /*return*/, pred];
                }
            });
        }); };
        this.getInputDims = function () { return __awaiter(_this, void 0, void 0, function () {
            var inputLayers, batchInputShape;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.loaded()];
                    case 1:
                        _a.sent();
                        inputLayers = this.pretrainedModel.inputLayers;
                        batchInputShape = inputLayers[0].batchInputShape;
                        return [2 /*return*/, [
                                batchInputShape[1],
                                batchInputShape[2],
                            ]];
                }
            });
        }); };
        this.getData = function (dataType) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (dataType !== 'train' && dataType !== 'eval') {
                    throw new Error("Datatype " + dataType + " unsupported");
                }
                return [2 /*return*/, {
                        xs: this.data[dataType].xs,
                        ys: this.data[dataType].ys,
                        classes: this.data.classes,
                    }];
            });
        }); };
        this.getModel = function () { return _this.model; };
        this.addData = function (origImages, origLabels, dataType) {
            if (dataType === void 0) { dataType = 'train'; }
            return __awaiter(_this, void 0, void 0, function () {
                var dims, _a, images, errors, labels, activatedImages, i, image$$1, activatedImage, xs, ys;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            this.callbackFn('onAddData', 'start', origImages, origLabels, dataType);
                            if (!origImages) {
                                throw new Error('You must supply images');
                            }
                            if (!origLabels) {
                                throw new Error('You must supply labels');
                            }
                            return [4 /*yield*/, this.getInputDims()];
                        case 1:
                            dims = _b.sent();
                            return [4 /*yield*/, translateImages(origImages, dims, origLabels)];
                        case 2:
                            _a = _b.sent(), images = _a.images, errors = _a.errors, labels = _a.labels;
                            if (images.length !== labels.length) {
                                throw new Error('Class mismatch between labels and images');
                            }
                            if (!(dataType === 'train' || dataType === 'eval')) return [3 /*break*/, 10];
                            activatedImages = [];
                            i = 0;
                            _b.label = 3;
                        case 3:
                            if (!(i < images.length)) return [3 /*break*/, 7];
                            image$$1 = images[i];
                            return [4 /*yield*/, this.cropAndActivateImage(image$$1)];
                        case 4:
                            activatedImage = _b.sent();
                            activatedImages.push(activatedImage);
                            return [4 /*yield*/, nextFrame()];
                        case 5:
                            _b.sent();
                            _b.label = 6;
                        case 6:
                            i++;
                            return [3 /*break*/, 3];
                        case 7:
                            this.data.classes = getClasses(labels);
                            xs = addData(activatedImages);
                            return [4 /*yield*/, nextFrame()];
                        case 8:
                            _b.sent();
                            ys = addLabels(labels, this.data.classes);
                            return [4 /*yield*/, nextFrame()];
                        case 9:
                            _b.sent();
                            this.data[dataType] = {
                                xs: xs,
                                ys: ys,
                            };
                            _b.label = 10;
                        case 10: return [4 /*yield*/, nextFrame()];
                        case 11:
                            _b.sent();
                            this.callbackFn('onAddData', 'complete', origImages, labels, dataType, errors);
                            return [2 /*return*/];
                    }
                });
            });
        };
        this.clearData = function (dataType) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.callbackFn('onClearData', 'start', dataType);
                if (dataType) {
                    this.data[dataType] = {};
                }
                this.data['train'] = {};
                this.data['eval'] = {};
                this.callbackFn('onClearData', 'complete', dataType);
                return [2 /*return*/];
            });
        }); };
        this.train = function (params) {
            if (params === void 0) { params = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var data, classes, _a, model$$1, history;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            this.callbackFn('onTrain', 'start', params);
                            return [4 /*yield*/, this.loaded()];
                        case 1:
                            _b.sent();
                            return [4 /*yield*/, this.getData('train')];
                        case 2:
                            data = _b.sent();
                            if (!data.xs) {
                                throw new Error('You must add some training examples');
                            }
                            if (!data.ys) {
                                throw new Error('You must add some training labels');
                            }
                            classes = Object.keys(data.classes).length;
                            if (classes <= 1) {
                                throw new Error('You must train with more than one class');
                            }
                            return [4 /*yield*/, train$1(this.pretrainedModel, data, classes, params, this.args)];
                        case 3:
                            _a = _b.sent(), model$$1 = _a.model, history = _a.history;
                            this.model = model$$1;
                            this.callbackFn('onTrain', 'complete', params, history);
                            return [2 /*return*/, history];
                    }
                });
            });
        };
        this.predict = function (origImage, label) { return __awaiter(_this, void 0, void 0, function () {
            var dims, _a, images, errors, data, img_1, predictedClass, classId, prediction, err_1;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 6, , 7]);
                        this.callbackFn('onPredict', 'start', origImage);
                        return [4 /*yield*/, this.loaded()];
                    case 1:
                        _b.sent();
                        if (!this.model) {
                            throw new Error('You must call train prior to calling predict');
                        }
                        return [4 /*yield*/, this.getInputDims()];
                    case 2:
                        dims = _b.sent();
                        return [4 /*yield*/, translateImages([origImage], dims)];
                    case 3:
                        _a = _b.sent(), images = _a.images, errors = _a.errors;
                        if (errors && errors.length && !images[0]) {
                            throw errors[0].error;
                        }
                        data = images[0];
                        return [4 /*yield*/, this.cropAndActivateImage(data)];
                    case 4:
                        img_1 = _b.sent();
                        predictedClass = tidy(function () {
                            var predictions = _this.model.predict(img_1);
                            // TODO: address this
                            return predictions.as1D().argMax();
                        });
                        return [4 /*yield*/, predictedClass.data()];
                    case 5:
                        classId = (_b.sent())[0];
                        predictedClass.dispose();
                        prediction = Object.entries(this.data.classes).reduce(function (obj, _a) {
                            var key = _a[0], val = _a[1];
                            var _b;
                            return (__assign({}, obj, (_b = {}, _b[val] = key, _b)));
                        }, {})[classId];
                        this.callbackFn('onPredict', 'complete', origImage, label, prediction);
                        return [2 /*return*/, prediction];
                    case 6:
                        err_1 = _b.sent();
                        console.error(err_1, origImage, label);
                        return [3 /*break*/, 7];
                    case 7: return [2 /*return*/];
                }
            });
        }); };
        this.evaluate = function (params) {
            if (params === void 0) { params = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var data, evaluation;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.callbackFn('onEvaluate', 'start', params);
                            return [4 /*yield*/, this.loaded()];
                        case 1:
                            _a.sent();
                            if (!this.model) {
                                throw new Error('You must call train prior to calling predict');
                            }
                            return [4 /*yield*/, this.getData('eval')];
                        case 2:
                            data = _a.sent();
                            if (!data.xs || !data.ys) {
                                throw new Error('You must add some evaluation examples');
                            }
                            return [4 /*yield*/, this.model.evaluate(data.xs, data.ys, params)];
                        case 3:
                            evaluation = _a.sent();
                            this.callbackFn('onEvaluate', 'complete', params, evaluation);
                            return [2 /*return*/, evaluation];
                    }
                });
            });
        };
        // handlerOrURL?: tf.io.IOHandler | string;
        this.save = function (handlerOrURL, params) {
            if (params === void 0) { params = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var savedModel;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.callbackFn('onSave', 'start', handlerOrURL, params);
                            return [4 /*yield*/, this.loaded()];
                        case 1:
                            _a.sent();
                            if (!this.model) {
                                throw new Error('You must call train prior to calling save');
                            }
                            return [4 /*yield*/, this.model.save(handlerOrURL || getDefaultDownloadHandler(this.data.classes), params)];
                        case 2:
                            savedModel = _a.sent();
                            this.callbackFn('onSave', 'complete', handlerOrURL, params, savedModel);
                            return [2 /*return*/, savedModel];
                    }
                });
            });
        };
        this.args = args;
        this.init();
    }
    return MLClassifier;
}());

export default MLClassifier;
export { PRETRAINED_MODELS_KEYS as PRETRAINED_MODELS };
